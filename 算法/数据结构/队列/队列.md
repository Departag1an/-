# 队列

## 普通队列

### 模板

```C++
// hh 表示队头，tt表示队尾
int q[N], hh = 0, tt = -1;

// 向队尾插入一个数
q[ ++ tt] = x;

// 从队头弹出一个数
hh ++ ;

// 队头的值
q[hh];

// 判断队列是否为空，如果 hh <= tt，则表示不为空
if (hh <= tt)
{

}
```

## 循环队列

### 模板

```C++
// hh 表示队头，tt表示队尾的后一个位置
int q[N], hh = 0, tt = 0;

// 向队尾插入一个数
q[tt ++ ] = x;
if (tt == N) tt = 0;

// 从队头弹出一个数
hh ++ ;
if (hh == N) hh = 0;

// 队头的值
q[hh];

// 判断队列是否为空，如果hh != tt，则表示不为空
if (hh != tt)
{

}
```

## 双端队列

### 模板

# 队列的常见应用

## 滑动窗口

**常见模型：找出滑动窗口中的最大值/最小值**

```C++
const int N = 1000010; // 定义常量 N，表示数组的最大大小
int n, k; // n 是数组的大小，k 是窗口的大小
int a[N], q[N]; // a 是存储输入数组的数组，q 是存储索引的队列
int hh = 0, tt = -1; // hh 表示队头索引，tt 表示队尾索引
for (int i = 0; i < n; i++) 
{
    // 判断队头是否已经滑出窗口
    if (hh <= tt && i - k + 1 > q[hh]) hh++;

    // 维护队列：去掉大于当前元素 a[i] 的索引
    while (hh <= tt && a[q[tt]] >= a[i]) tt--;

    // 将当前索引 i 添加到队列中
    q[++tt] = i;

    // 当 i 大于等于 k-1 时，输出当前窗口的最小值
    if (i >= k - 1) printf("%d ", a[q[hh]]);
}

```
[**常见模型：无重复字符的最长子串长度**](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/) *(点击转到模版题)*

```C++
const int N = 1000010; // 定义常量 N，表示数组的最大大小
int n, k; // n 是数组的大小，k 是窗口的大小
int a[N], q[N]; // a 是存储输入数组的数组，q 是存储索引的队列
int hh = 0, tt = -1; // hh 表示队头索引，tt 表示队尾索引
int ans = 0; // 最长不重复子串的长度
for (int i = 0; i < n; i++) 
{
    // 判断队头是否已经滑出窗口
    if (hh <= tt && i - k + 1 > q[hh]) hh++;

    // 维护队列：去掉大于当前元素 a[i] 的索引
    while (hh <= tt && a[q[tt]] >= a[i]) tt--;

    // 将当前索引 i 添加到队列中
    q[++tt] = i;

    // 当 i 大于等于 k-1 时，更新最长不重复子串的长度
    if (i >= k - 1) 
    {
        ans = max(ans, i - q[hh] + 1);
        hh++;
    }
}

```
## 分析
**hh一定是<=tt**在这个基础上来判断和维护  
1. 判断对头是否已经滑出窗口**i-k+1 > q[hh]**(i-k+1是窗口的左边界，q[hh]是队头索引，如果左边界大于队头索引，说明队头已经滑出窗口，需要将队头出队) 即**h++**  
2. 维护队列：去掉大于当前元素 a[i] 的索引**a[q[tt]] >= a[i]**(如果队尾元素大于当前元素，说明队尾元素不可能成为窗口的最小值，需要将队尾出队) 即**tt--**  
3. **每次遍历将当前索引i添加到队列中 q[++tt] = i**  
**需要注意的是tt初始化为-1这里是++tt**  
4. 当 i 大于等于 k-1 时，输出当前窗口的最小值**if (i >= k - 1) printf("%d ", a[q[hh]]);**


## 单调队列
### 维护单调性
### 基础容器
# KMP算法

## 算法原理  
### 前置知识点：前缀表 前后缀  
1.前缀表：记录字符串中的每个子串的最大相等前后缀的长度  
例：设字符串T=“aabaaf”，我们求一下T的前缀表(用一个数组名为next的数组表示)。

第一个子串是t0=“a”，易知该子串没有前缀也没有后缀，故next[0]=0  
第二个子串是t1=“aa”，该子串的前缀为"a"，后缀也为"a"，故next[1]=1  
第三个子串是t2=“aab”，该子串的后缀中一定会有"b"，前缀中一定不含有"b"，则其没有相等的前后缀，故next[2]=0  
第四个子串是t3=“aaba”，该子串的最大相等前后缀为"a"，长度为1，故next[3]=1  
第五个子串是t4=“aabaa”，该子串的最大相等前后缀为"aa"，长度为2，故next[4]=2  
第六个子串是t5=“aabaaf”，该子串的后缀中一定会有"f"，前缀中一定不含有"f"，则其没有相等的前后缀，故next[5]=0  

| j    | 0 | 1 | 2 | 3 | 4 | 5 |
|------|---|---|---|---|---|---|
| T    | a | a | b | a | a | f |
| next | 0 | 1 | 0 | 1 | 2 | 0 |  

前缀表决定了**子串指针j在匹配失败时回溯到的位置。**

#### 结论：前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。

2.前后缀：前缀指的是不包含尾字符的所有子串；后缀指的是不包含首字符的所有子串

### 理解了前缀表及其作用后，，KMP算法就可以整体上分为两步： 
一、计算前缀表。  
二、根据前缀表移动两个指针进行匹配。

## 模板

```c++
// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度
求模式串的Next数组：
for (int i = 2, j = 0; i <= m; i ++ )
{
    while (j && p[i] != p[j + 1]) j = ne[j];
    if (p[i] == p[j + 1]) j ++ ;
    ne[i] = j;
}

// 匹配
for (int i = 1, j = 0; i <= n; i ++ )
{
    while (j && s[i] != p[j + 1]) j = ne[j];
    if (s[i] == p[j + 1]) j ++ ;
    if (j == m)
    {
        j = ne[j]; //完成匹配后，j要回退
        // 匹配成功后的逻辑
    }
}

```

## 算法分析

i 只会向前移动 n 次（主字符串的长度）。  
j 在每次不匹配后可能会回退，但由于使用 next 数组的特性，所有的 j 的回退总和也是有限的，最多也为 m。  
因此，整个匹配过程的时间复杂度为 O(n + m)。


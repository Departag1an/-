# 离散化
*****
离散化是一种将数据映射到连续整数区间的技术，常用于优化算法的时间复杂度。离散化的核心思想是将数据按照某种规则进行排序，然后将其映射到连续的整数区间。这样可以有效地减少数据的规模，从而提高算法的效率。

离散化的步骤如下：

1. 对数据进行排序，可以使用快速排序、归并排序等排序算法。
2. 将排序后的数据映射到连续的整数区间。可以使用哈希表或者数组来实现。
3. 在算法中使用离散化后的数据，而不是原始数据。
4. 在算法中需要使用原始数据时，可以通过离散化后的数据反推原始数据。
5. 在算法中需要使用原始数据的索引时，可以通过离散化后的数据反推原始数据的索引。

**离散化是一种极其特殊的哈希方式**


## 模板
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int n, m;
int a[N], b[N];
int c[N];
int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i++)
        cin >> a[i];
    for (int i = 0; i < m; i++)
        cin >> b[i];
    int len = unique(a, a + n) - a; // 去重
    sort(a, a + len); // 排序
    for (int i = 0; i < m; i++)
    {
        int l = lower_bound(a, a + len, b[i]) - a; // 二分查找
        c[i] = l;
    }
    for (int i = 0; i < m; i++)
        cout << c[i] << " ";
    return 0;
}
```

## 例题
### [P1972 [NOI2011] 哆啦A梦](https://www.luogu.com.cn/problem/P1972)
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int n, m;
int a[N], b[N];
int c[N];
int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i++)
        cin >> a[i];
    for (int i = 0; i < m; i++)
        cin >> b[i];
    int len = unique(a, a + n) - a; // 去重
    sort(a, a + len); // 排序
    for (int i = 0; i < m; i++)
    {
        int l = lower_bound(a, a + len, b[i]) - a; // 二分查找
        c[i] = l;
    }
    for (int i = 0; i < m; i++)
        cout << c[i] << " ";
    return 0;
}
```
### [P3149 [USACO16OPEN]248 G](https://www.luogu.com.cn/problem/P3149)
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int n, m;
int a[N], b[N];
int c[N];
int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i++)
        cin >> a[i];
    for (int i = 0; i < m; i++)
        cin >> b[i];
    int len = unique(a, a + n) - a; // 去重
    sort(a, a + len); // 排序
    for (int i = 0; i < m; i++)
    {
        int l = lower_bound(a, a + len, b[i]) - a; // 二分查找
        c[i] = l;
    }
    for (int i = 0; i < m; i++)
        cout << c[i] << " ";
    return 0;
}
```

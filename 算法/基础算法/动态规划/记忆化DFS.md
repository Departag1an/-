### 记忆化 DFS

#### 应用
- 具有递推或递归性质的问题
- **典型问题**：
  - 斐波那契数列
  - 最长公共子序列
  - 爬楼梯问题
  - 背包问题
  - 路径计数等

#### 与递推 DP 表的对比
- **函数栈或循环栈开销大**：
  - 函数栈在深度递归时，栈帧开销可能导致栈溢出；循环栈需要动态管理空间。
  - 递推 DP 表的空间使用通常更高效，且无递归调用的额外开销。

- **函数栈调用实现简单，逻辑清晰**：
  - 递归实现通常比迭代更直观，特别是在处理树或图时。
  - 记忆化可以在递归过程中简洁地缓存结果，提高效率。

#### 实现方式
- **函数栈 + 记忆化数组/哈希表**：
  - 通过递归调用并在全局数组或哈希表中存储已计算的结果，减少重复计算。

    ```cpp
    std::vector<int> memo(n + 1, -1);
    int dfs(int n) {
        if (memo[n] != -1) return memo[n];
        // 计算逻辑
        memo[n] = result;
        return memo[n];
    }
    ```

- **循环栈 + 记忆化数组/哈希表**：
  - 使用显式栈进行迭代，同时使用数组或哈希表存储状态结果。

    ```cpp
    std::stack<int> s;
    std::vector<int> memo(n + 1, -1);
    s.push(initialState);
    
    while (!s.empty()) {
        int state = s.top();
        s.pop();
        if (memo[state] == -1) {
            // 计算逻辑
            memo[state] = result;
            // 推入新的状态
        }
    }
    ```

### 动态规划（DP）表

#### 应用
- 适用于具有重叠子问题和最优子结构性质的问题
- **典型问题**：
  - 0/1背包问题
  - 最长递增子序列
  - 矩阵链乘法
  - 最短路径问题（如 Dijkstra 或 Floyd-Warshall）

#### 实现方式
- 使用二维或一维数组表示状态，依据状态转移方程进行计算。

    ```cpp
    int dp[n + 1];
    dp[0] = base_case;
    for (int i = 1; i <= n; ++i) {
        dp[i] = calculate(dp, i); // 根据转移方程计算
    }
    ```

### 性能变化总结
#### 1. 记忆化 DFS（函数栈）
- **时间复杂度**：O(n)
- **空间复杂度**：O(n)（栈 + 记忆化数组）
- **大规模问题**：可能导致栈溢出。

#### 2. 循环栈 + 记忆化
- **时间复杂度**：O(n)
- **空间复杂度**：O(n)（灵活调整）
- **大规模问题**：避免栈溢出，性能稳定。

#### 3. DP 表
- **时间复杂度**：O(n) 或 O(n*m)
- **空间复杂度**：O(n) 或 O(n*m)（优化）
- **大规模问题**：性能最佳，开销最低。

### 总结
- **小规模**：三种方法性能接近。
- **中等规模**：DP 表优势开始显现，减少了重叠子问题的重复计算。
- **大规模**：DP 表通常表现最佳，记忆化 DFS 可能失效。


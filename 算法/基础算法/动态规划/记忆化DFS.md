# 记忆化 DFS

## 应用

- 具有递推或递归性质的问题
- **典型问题**：
  - 斐波那契数列
  - 最长公共子序列
  - 爬楼梯问题
  - 背包问题
  - 路径计数等

## 与递推 DP 表的对比

- **函数栈或循环栈开销大**：
  - 函数栈在深度递归时，栈帧开销可能导致栈溢出；循环栈需要动态管理空间。
  - 递推 DP 表的空间使用通常更高效，且无递归调用的额外开销。

- **函数栈调用实现简单，逻辑清晰**：
  - 递归实现通常比迭代更直观，特别是在处理树或图时。
  - 记忆化可以在递归过程中简洁地缓存结果，提高效率。

## 实现方式

- **函数栈 + 记忆化数组/哈希表**：
  - 通过递归调用并在全局数组或哈希表中存储已计算的结果，减少重复计算。

    ```cpp
    std::vector<int> memo(n + 1, -1);
    int dfs(int n) {
        if (memo[n] != -1) return memo[n];
        // 计算逻辑
        memo[n] = result;
        return memo[n];
    }
    ```

- **循环栈 + 记忆化数组/哈希表**：
  - 使用显式栈进行迭代，同时使用数组或哈希表存储状态结果。

    ```cpp
    std::stack<int> s;
    std::vector<int> memo(n + 1, -1);
    s.push(initialState);
    
    while (!s.empty()) {
        int state = s.top();
        s.pop();
        if (memo[state] == -1) {
            // 计算逻辑
            memo[state] = result;
            // 推入新的状态
        }
    }
    ```

## 性能变化总结

#### 1. 记忆化 DFS（函数栈）

- **时间复杂度**：O(n)
- **空间复杂度**：O(n)（栈 + 记忆化数组）
- **大规模问题**：可能导致栈溢出。

#### 2. 循环栈 + 记忆化

- **时间复杂度**：O(n)
- **空间复杂度**：O(n)（灵活调整）
- **大规模问题**：避免栈溢出，性能稳定。

#### 3. DP 表

- **时间复杂度**：O(n) 或 O(n*m)
- **空间复杂度**：O(n) 或 O(n*m)（优化）
- **大规模问题**：性能最佳，开销最低。

### 总结

- **小规模**：三种方法性能接近。**(都可以)**
- **中等规模**：DP 表优势开始显现，减少了重叠子问题的重复计算。**(都可以)**
- **大规模**：DP 表通常表现最佳，记忆化 DFS 可能失效。**(DP / 记忆化Stack)**

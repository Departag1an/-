# 最长递增子序列
## 思路
- 要求`最长` `递增` `子序列`。注意点:__是求的子序列__
- 这种不连续的问题，而并非区间。一般只能是用动态规划的方式解决
- 接下来跟着我进行沉浸式推理：
  - 首先，我们想要得到一个最长的递增子序列，第一反应肯定让这个序列渐渐变长。
  - 但是，我们又会遇到一些特殊情况:
    - 我们尝试让下一个元素作为递增序列的拓展时，由于元素更小而中断
    - 而如果元素持续减小，至少我们能知道，这样的操作不会影响整体最长递增序列的地位
    - 而这时元素大小又开始增长，就形成了多段递增递减序列
    - 或者，如果有两小段子递增序列时，我们不知道整体的最长递增是多少
    - 到此为止，我们基本可以确定，该问题不是线性推导可以得到的
    - 因此我们考虑动态规划来优化思路：
      - 根据问题拆解子问题为(状态定义):长度为l的最长递增子序列
      - 转移: 
   \[
   dp[i] = \max(dp[i], dp[j] + 1) \quad \text{(对于所有 \(j < i\) 且 \(a[j] < a[i]\))}.
   \]




        - **这是一个暴力转移，时间复杂度为O(n^2)**
        - 他会在新状态计算时枚举之前所有状态
        - 显然,如果一个拓展成功 **某个a[j] < a[i]** 是必须的条件
        - 使`dp[i]`是所有 **a[j] < a[i]** 的`dp[j]+1`中最大的那个,以保证dp严格
      - 这样看来我们就完成了dp的定义和转移。我们只需要暴力推导一下DP数组即可得到答案
      - 时间复杂度为\(O(n^2)\)
代码如下:
```cpp
#include <bits/stdc++.h>
using namespace std;        
const int MAXN = 100005;
int a[MAXN], dp[MAXN];

int main() {
    int n;
    cin >> n;        
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }

    int ans = 0;
    for (int i = 1; i <= n; i++) {
        dp[i] = 1;
        for (int j = 1; j < i; j++) {
            if (a[j] < a[i]) {                
                dp[i] = max(dp[i], dp[j] + 1);
            }
        }
        ans = max(ans, dp[i]);
    }

    cout << ans << endl;

    return 0;
}
```


## 这里我们提供一个更优美的优化思路  `二分优化`
- 由于我们每次转移时，都是在寻找`dp[j]`中`a[j] < a[i]`的最大的那个`dp[j]`
- 我们可以维护一个数组`g`，`g[i]`表示长度为`i`的递增子序列的末尾元素的最小值
- 这样，我们就可以使用二分查找来找到`g`数组中第一个大于等于`a[i]`的位置`pos`
- 如果`pos`等于`g`数组的长度，说明`a[i]`可以作为新的最长递增子序列的末尾元素，我们就可以将`a[i]`添加到`g`数组的末尾 
- 否则，我们就可以将`g[pos]`更新为`a[i]`，这样就可以保证`g`数组中的元素尽可能的小，从而使得`g`数组的长度尽可能的大
- 这样，我们就可以在`O(nlogn)`的时间复杂度内解决这个问题
- 代码如下:
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100005;
int a[MAXN], g[MAXN];

int main() {
    int n;
    cin >> n;        
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }

    int len = 0;
    for (int i = 1; i <= n; i++) {        
        int pos = upper_bound(g + 1, g + 1 + len, a[i]) - g;
        if (pos == len + 1) {
            g[++len] = a[i];
        } else {
            g[pos] = a[i];
        }
    }

    cout << len << endl;

    return 0;
}
```
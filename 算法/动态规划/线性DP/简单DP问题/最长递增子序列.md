# 最长递增子序列
## 思路
- 要求`最长` `递增` `子序列`。注意点:__是求的子序列__
- 这种不连续的问题，而并非区间。一般只能是用动态规划的方式解决
### 接下来跟着我进行沉浸式推理：
  - 首先，我们想要得到一个最长的递增子序列，第一反应肯定让这个序列渐渐变长。
  - 但是，我们又会遇到一些特殊情况:
    - 我们尝试让下一个元素作为递增序列的拓展时，由于元素更小而中断
    - 而如果元素持续减小，至少我们能知道，这样的操作不会影响整体最长递增序列的地位
    - 而这时元素大小又开始增长，就形成了多段递增递减序列
    - 或者，如果有两小段子递增序列时，我们不知道整体的最长递增是多少
    - 到此为止，我们基本可以确定，该问题不是线性推导可以得到的
    - 因此我们考虑动态规划来优化思路：
      - 根据问题拆解子问题为(状态定义):长度为l的最长递增子序列
      - 转移: 
   \[
   dp[i] = \max(dp[i], dp[j] + 1) \quad \text{(对于所有 \(j < i\) 且 \(a[j] < a[i]\))}.
   \]




        - **这是一个暴力转移，时间复杂度为O(n^2)**
        - 他会在新状态计算时,枚举之前 **`所有状态组合新状态的所有可能`**
        - 显然,如果一个拓展成功 **某个a[j] < a[i]** 是必须的条件
        - 使`dp[i]`是所有 **a[j] < a[i]** 的`dp[j]+1`中最大的那个,以保证dp严格
      - 这样看来我们就完成了dp的定义和转移。我们只需要暴力推导一下DP数组即可得到答案
      - 时间复杂度为\(O(n^2)\)
代码如下:
```cpp
#include <bits/stdc++.h>
using namespace std;        
const int MAXN = 100005;
int a[MAXN], dp[MAXN];

int main() {
    int n;
    cin >> n;        
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }

    int ans = 0;
    for (int i = 1; i <= n; i++) {
        dp[i] = 1;
        for (int j = 1; j < i; j++) {
            if (a[j] < a[i]) {                
                dp[i] = max(dp[i], dp[j] + 1);
            }
        }
        ans = max(ans, dp[i]);
    }

    cout << ans << endl;

    return 0;
}
```


## 这里我们提供一个更优美的优化思路  `二分优化`
- 由于我们每次转移时，都是在寻找`dp[j]`中`a[j] < a[i]`的最大的那个`dp[j]`
- 这样会有有一些状态冗余，因为`a[j] < a[i]`的`dp[j]+1`不一定是最优的
- 因此，我们可以维护一个数组`g`，其中`g[i]`表示长度为`i`的递增子序列的末尾元素的最小值
  - 维护最小值的原因是，这样可以保证`g`数组中的元素尽可能小，从而使得后续的元素更容易插入到`g`数组中，形成更长的递增子序列
  - 这样，我们就可以利用g数组的单调性，使用二分查找来找到`g`数组中第一个大于等于`a[i]`的位置`pos`，然后更新`g[pos] = a[i]`    
  - 如果`pos`等于`len + 1`，说明`a[i]`可以作为新的最长递增子序列的末尾元素，因此更新`g[++len] = a[i]`
- 这样做的时间复杂度为\(O(n \log n)\)
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100005;
int a[MAXN], g[MAXN];

int main() {
    int n;
    cin >> n;        
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }

    int len = 0;
    for (int i = 1; i <= n; i++) {        
        int pos = upper_bound(g + 1, g + 1 + len, a[i]) - g;
        if (pos == len + 1) {
            g[++len] = a[i];
        } else {
            g[pos] = a[i];
        }
    }

    cout << len << endl;

    return 0;
}
```
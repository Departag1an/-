# 周赛64  https://ac.nowcoder.com/acm/contest/92662

## E 小红的字符串重排
### https://ac.nowcoder.com/acm/contest/92662/E
```C++
//		*	*	*	*
//		字符串重排

#include<bits/stdc++.h>
using namespace std;
typedef long long LL;

int t,n;
void solve(){
	string s;
	cin>>s;
	n=s.size();
	int cnt[500];
	memset(cnt,0,sizeof(cnt));
	int mx=0;
	vector<pair<char, int>>v(n);
	vector<char> ans(n);
	for(int i=0;i<n;i++)
	{
		v[i].first=s[i],v[i].second=i;//v的key存字母，value存下标，而v的下标是0，1，2... n-1  
		cnt[s[i]]++;//计数，记录每种字母的数量  
		mx=max(mx,cnt[s[i]]);
	}
	if(mx>n/2)//最大的重复字母的数量不能大于s的长度的一半  
	{
		cout<<-1<<endl;
		return ;
	}
	//按字母顺序排序，排完序后v按字典序的顺序排列，相同的字母挨在一起，但是字母对应的下标也会跟着变，因为这是键值对  
	sort(v.begin(), v.end(), [](const pair<char,int>&v1, const pair<char,int>&v2){return v1.first<v2.first;});
	for(int i=0;i<n;i++)
	{
		//cout<<v[i].second<<" "<<v[(i+mx)%n].first<<endl;
		ans[v[i].second]=v[(i+mx)%n].first;//v[i].second为字母的下标，ans记录为该下标（v[i].second）对应的新的字母，  
        //就是v[(i+m)%n]位置的字母
	}
	cout<<string(ans.begin(), ans.end())<<endl;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	t=1;
	//cin>>t;
	while(t--){
		solve();
	}
	return 0;
}

```

```C++
#include<bits/stdc++.h>
using namespace std;
string s;

int main()
{
    ios::sync_with_stdio(0),cin.tie(); 
    cin>>s;
    vector<pair<char,int>> a(s.size());
    string ans(s.size(), ' ');
    int cnt[500];
    memset(cnt,0,sizeof(cnt));
    int mx=0;
    for(int i=0;i<s.size();i++)
    {
        a[i].first=s[i],a[i].second=i;
        cnt[s[i]-'a']++;
        mx=max(mx,cnt[s[i]-'a']);
    }
    if(mx>s.size()/2)
    {
        cout<<-1<<endl;
        return 0;
    }
    sort(a.begin(),a.end(),[](const pair<char,int>&a1,const pair<char , int >&a2)
         {return a1.first<a2.first;});
    for(int i=0;i<s.size();i++)
    {
        ans[a[i].second]=a[(i+mx)%s.size()].first;
        
    }
     cout << ans << endl;
    return 0;
}

```

## 思路
1. 首先统计每个字母出现的次数，如果出现次数大于等于字符串长度的一半，则返回-1
2. 将字符串中的字母和下标存储到数组中，并按照字母排序
3. 遍历数组，将每个字母替换为距离它最远的字母，即下标为 **(i+mx)%s.size()** 的字母
4. 输出结果

# F小红的树上路径查询（easy）https://ac.nowcoder.com/acm/contest/92662/F

